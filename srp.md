---
description: Принцип единственной ответственности | Single Responsibility Principe | SRP
---

# SRP

![&#x41F;&#x440;&#x438;&#x43D;&#x446;&#x438;&#x43F; &#x435;&#x434;&#x438;&#x43D;&#x441;&#x442;&#x432;&#x435;&#x43D;&#x43D;&#x43E;&#x439; &#x43E;&#x442;&#x432;&#x435;&#x442;&#x441;&#x442;&#x432;&#x435;&#x43D;&#x43D;&#x43E;&#x441;&#x442;&#x438;](.gitbook/assets/image%20%281%29.png)

 SRP звучит так:

> Существует лишь одна причина, приводящая к изменению класса.

Ответственность – это причина изменения кода.

Если при изменении кода, отвечающего за одну ответственность, в приложении появляются исправления кода, отвечающего за другую ответственность – есть нарушения SRP.

Антипаттерн – божественный объект.

### Пример нарушения SRP

У предприятия есть система для работы с закупкой товаров. Несколько продавцов выставляют свои предложения \(offers\) на торги. Предприятие выбирает среди них наиболее оптимальный вариант. Разработчик №1, согласно поставленной задаче создал класс для работы с закупкой.

```javascript
export class Purchase {
    constructor (offers) {
        this._offers = offers || [];
    }

    /**
     * Вычисляет самое оптимальное коммерческое предложение
     * от продавцов, исходя из наименьшей цены, которую они предложили
     * @private
     */
    _calculateOptimalSeller () {
        return this._offers.find(offer => {
           // ...
        });
    }

    /**
     * Актор 1. Плановый отдел.
     *
     * Вычисление планируемой цены закупки (для отчета)
     *
     * Плановый отдел планирует
     * сколько денег предприятие потратит в следующем месяце.
     * Поэтому им важно знать предполагаемую будущую цену закупки.
     * Торги еще не состоялись, но по данным цен от продавцов,
     * уже можно представить сколько денег на эту закупку потребуется
     * @returns {*}
     */
    getProspectivePrice () {
        const seller = this._calculateOptimalSeller();
        return seller.price;
    }
}
```

По списку закупок потом формируются отчеты:

```javascript
const purchases = [
    new Purchase([
        {name: 'ООО Рога', title: 'Поставка воды', price: 1000},
        {name: 'ООО Копыта', title: 'Поставка воды', price: 1200},
        {name: 'ООО Золотой теленок', title: 'Поставка воды', price: 1500},
    ]),
    new Purchase([
        {name: 'ООО Рога', title: 'Поставка канцелярии', price: 5000},
        {name: 'ООО Копыта', title: 'Поставка канцелярии', price: 5500},
        {name: 'ООО Золотой теленок', title: 'Поставка канцелярии', price: 5800},
    ]),
];
generateBudgetingReport(purchases);
```

Спустя время, актор 2 - Отдел маркетинга захотел мониторить дельту предлагаемых продавцами цен. Отдел маркетинга попросил дать им отчет по этим ценам. Для этого разработчик №2 внёс изменения в класс закупки, нарушив принцип SRP.

```javascript
export class Purchase {
    
    // ... предыдущий код скрыт

    /**
     * Актор 2. Отдел маркетинга.
     *
     * Максимальная из предложенных продавцами цен
     */
    getMaximalPrice () {
        const seller = this._offers.find(offer => {
            // ...
        });
        return seller.price;
    }

    /**
     * Актор 2. Отдел маркетинга.
     *
     * Минимальная из предложенных продавцами цен
     *
     * Чтобы не дублировать код, разработчик №2 вернул результат getProspectivePrice
     * В итоге, теперь Purchase имеет две ответственности (Актор 1 и Актор 2)
     * @returns {*}
     */
    getMinimalPrice () {
        return this.getProspectivePrice();
    }
}
```

Шли годы. Плановый составлял бюджет на следующий месяц, а отделу маркетинга спокойно смотрел отчеты по дельтам цен. За это время класс Purchase разросся на несколько сотен строк кода. Предприятие тем временем перешло на закупки через аукцион. И вдруг, после некоторых изменений в законах победитель торгов стал вычисляться не по минимальной цене, а по средней из предложенных. Актор 1, плановый отдел нанял разработчика №3 оперативно поменять код под новые требования. В спешке, разработчик меняет алгоритм в \_calculateOptimalSeller. Он даже не знает про Актора 2, которые делает свои отчеты. В итоге, у планового отдела все хорошо, а вот у отдела маркетинге в отчетах стали появляться неверные цифры.

